import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';
import '../notifications/notification_controller.dart';
import 'location_controller.dart';

class AppLifecycleHandler extends GetxController with WidgetsBindingObserver {
  final LocationController locationController = Get.find<LocationController>();
  late final NotificationController notificationController;
  final box = GetStorage();

  // Add state tracking
  final _isHandlingLifecycleChange = false.obs;

  @override
  void onInit() {
    super.onInit();
    WidgetsBinding.instance.addObserver(this);
    _initializeControllers();
    _checkInitialState();
  }

  Future<void> _initializeControllers() async {
    // Ensure proper initialization order
    try {
      if (!Get.isRegistered<NotificationController>()) {
        notificationController = Get.put(NotificationController());
      } else {
        notificationController = Get.find<NotificationController>();
      }
    } catch (e) {
      print('‚ùå Error initializing controllers: $e');
    }
  }

  @override
  void onClose() {
    WidgetsBinding.instance.removeObserver(this);
    super.onClose();
  }

  Future<void> _checkInitialState() async {
    try {
      // Add retry mechanism for critical operations
      int retryCount = 0;
      bool success = false;

      while (!success && retryCount < 3) {
        try {
          await _initializeControllers();
          final hasLogout = await notificationController.checkPendingLogout();
          if (hasLogout) {
            // Wait for logout to complete before proceeding
            await Future.delayed(const Duration(milliseconds: 500));
          }
          success = true;
        } catch (e) {
          retryCount++;
          await Future.delayed(Duration(seconds: retryCount));
        }
      }

      if (!success) {
        print('‚ö†Ô∏è Failed to check initial state after retries');
      }
    } catch (e) {
      print('‚ùå Error in initial state check: $e');
    }
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) async {
    super.didChangeAppLifecycleState(state);

    // Prevent concurrent lifecycle handling
    if (_isHandlingLifecycleChange.value) {
      print('‚ö†Ô∏è Already handling lifecycle change, skipping...');
      return;
    }

    _isHandlingLifecycleChange.value = true;

    try {
      switch (state) {
        case AppLifecycleState.paused:
          await _handleAppBackground();
          break;
        case AppLifecycleState.resumed:
          await _handleAppForeground();
          break;
        case AppLifecycleState.inactive:
          await _handleAppInactive();
          break;
        case AppLifecycleState.detached:
          await _handleAppTermination();
          break;
        default:
          break;
      }
    } finally {
      _isHandlingLifecycleChange.value = false;
    }
  }

  Future<void> _handleAppBackground() async {
    print('üì± App moved to background');
    try {
      // Use atomic write operations
      await Future.wait([
        box.write('was_in_background', true),
        box.write('background_timestamp', DateTime.now().toIso8601String()),
        _saveAppState(),
      ]);

      print('‚úÖ App background state handled successfully');
    } catch (e) {
      print('‚ùå Error handling background state: $e');
    }
  }

  Future<void> _handleAppForeground() async {
    print('üì± App moved to foreground');
    try {
      final wasInBackground = box.read('was_in_background') ?? false;
      final backgroundTimestamp = box.read('background_timestamp');

      print(
          'Was in background: $wasInBackground (since: $backgroundTimestamp)');

      if (wasInBackground) {
        // Add delay before checking pending logout
        await Future.delayed(const Duration(milliseconds: 500));

        // Implement timeout for background operations
        final timeout = const Duration(seconds: 5);
        await Future.wait([
          _processForegroundTasks(),
          box.remove('was_in_background'),
          box.remove('background_timestamp'),
        ]).timeout(timeout, onTimeout: () {
          print('‚ö†Ô∏è Foreground operations timed out');
          return [];
        });
      }
    } catch (e) {
      print('‚ùå Error in foreground handlers: $e');
    }
  }

  Future<void> _processForegroundTasks() async {
    try {
      // Ensure notification controller is initialized
      if (!Get.isRegistered<NotificationController>()) {
        await Get.put(NotificationController());
      }

      // First check for pending logout
      final hasLogout = await notificationController.checkPendingLogout();

      // Only proceed with other operations if no logout was performed
      if (!hasLogout) {
        await Future.wait([
          notificationController.loadNotifications(),
          // Uncomment when location updates are needed
          // locationController.updateLocation(),
        ]);
      }

      print('‚úÖ App foreground handlers completed successfully');
    } catch (e) {
      print('‚ùå Error processing foreground tasks: $e');
      rethrow; // Propagate error for proper handling
    }
  }

  Future<void> _handleAppInactive() async {
    try {
      // Handle transitional state
      print('üì± App became inactive');
      await _saveAppState();
    } catch (e) {
      print('‚ùå Error handling inactive state: $e');
    }
  }

  Future<void> _handleAppTermination() async {
    try {
      print('üì± App is being terminated');
      await _saveAppState();
      // Cleanup operations
      await Future.wait([
        box.write('last_termination', DateTime.now().toIso8601String()),
        _cleanupResources(),
      ]);
      print('‚úÖ App termination handled successfully');
    } catch (e) {
      print('‚ùå Error handling app termination: $e');
    }
  }

  Future<void> _saveAppState() async {
    try {
      final stateData = {
        'timestamp': DateTime.now().toIso8601String(),
        'notifications_count': notificationController.notifications.length,
        // Add other relevant state data
      };

      await box.write('app_state', stateData);
      print('‚úÖ App state saved successfully');
    } catch (e) {
      print('‚ùå Error saving app state: $e');
    }
  }

  Future<void> _cleanupResources() async {
    try {
      // Clean up any resources that need to be released
      // e.g., close streams, cancel subscriptions, etc.
    } catch (e) {
      print('‚ùå Error cleaning up resources: $e');
    }
  }
}
